{"ast":null,"code":"import * as pdfjsLib from 'pdfjs-dist';\nimport { PDFDocument, rgb } from 'pdf-lib';\n\n// Set up the worker for pdf.js\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\nexport async function DownloadUpdatedFile(pdfData, jsonResult) {\n  const response = await fetch(pdfData.url);\n  const arrayBuffer = await response.arrayBuffer();\n  const pdfDoc = await PDFDocument.load(arrayBuffer);\n  const form = pdfDoc.getForm();\n\n  // Set values\n  for (let i = 0; i < jsonResult.length; i++) {\n    const fieldName = jsonResult[i].inputField.fieldName;\n    const field = form.getTextField(fieldName);\n    field.setText(jsonResult[i].inputField.value);\n  }\n\n  // fields become uneditable\n  form.flatten();\n  const pdfBytes = await pdfDoc.save();\n\n  // Trigger file download in the browser\n  const blob = new Blob([pdfBytes], {\n    type: 'application/pdf'\n  });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = 'filled-form-' + pdfData.name + '.pdf';\n  a.click();\n  URL.revokeObjectURL(url);\n}\n_c = DownloadUpdatedFile;\nexport async function PDF_TO_JSON(pdfData) {\n  const loadingTask = pdfjsLib.getDocument({\n    url: pdfData.url,\n    cMapUrl: \"https://unpkg.com/pdfjs-dist@latest/cmaps/\",\n    cMapPacked: true\n  });\n  const pdf = await loadingTask.promise;\n  console.log(\"PDF loaded successfully\");\n  const results = [];\n  for (let i = 1; i <= pdf.numPages; i++) {\n    const page = await pdf.getPage(i);\n    const textContent = await page.getTextContent();\n    const annotations = await page.getAnnotations();\n\n    // Find the \"Region\" label\n    let regionLabel = null;\n    for (const item of textContent.items) {\n      if (item.str.trim() === \"Region\") {\n        const [,,,, x, y] = item.transform;\n        regionLabel = {\n          x,\n          y\n        };\n        break;\n      }\n    }\n    if (regionLabel) {\n      // Find the nearest input field above the \"Region\" label\n      let nearestField = null;\n      let minDistance = Infinity;\n      for (const annotation of annotations) {\n        const [x1, y1, x2, y2] = annotation.rect;\n        const fieldY = (y1 + y2) / 2;\n        const fieldX = (x1 + x2) / 2;\n\n        // Check if the field is above the label and within horizontal range\n        if (fieldY > regionLabel.y && Math.abs(fieldX - regionLabel.x) < 100) {\n          const distance = fieldY - regionLabel.y;\n          if (distance < minDistance) {\n            minDistance = distance;\n            nearestField = {\n              label: \"Region\",\n              inputField: {\n                fieldName: annotation.fieldName || \"Unnamed Field\",\n                inputType: annotation.fieldType || \"Unknown\",\n                value: annotation.fieldValue || \"\",\n                options: annotation.options ? annotation.options.map(opt => opt.displayValue || opt.value) : []\n              }\n            };\n          }\n        }\n      }\n      if (nearestField) {\n        results.push(nearestField);\n      }\n    }\n\n    // Find the \"Court File No. (if known)\" label\n    let courtFileLabel = null;\n    for (const item of textContent.items) {\n      if (item.str.trim() === \"Court File No. (if known)\") {\n        const [,,,, x, y] = item.transform;\n        courtFileLabel = {\n          x,\n          y\n        };\n        break;\n      }\n    }\n    if (courtFileLabel) {\n      // Find the nearest text input field above the label\n      let nearestField = null;\n      let minDistance = Infinity;\n      for (const annotation of annotations) {\n        const [x1, y1, x2, y2] = annotation.rect;\n        const fieldY = (y1 + y2) / 2;\n        const fieldX = (x1 + x2) / 2;\n\n        // Check if the field is above the label, within horizontal range, and is a text field\n        if (fieldY > courtFileLabel.y && Math.abs(fieldX - courtFileLabel.x) < 100 && annotation.fieldType === \"Tx\") {\n          const distance = fieldY - courtFileLabel.y;\n          if (distance < minDistance) {\n            minDistance = distance;\n            nearestField = {\n              label: \"Court File No. (if known)\",\n              inputField: {\n                fieldName: annotation.fieldName || \"Unnamed Field\",\n                inputType: annotation.fieldType || \"Unknown\",\n                value: annotation.fieldValue || \"\",\n                options: []\n              }\n            };\n          }\n        }\n      }\n      if (nearestField) {\n        results.push(nearestField);\n      }\n    }\n  }\n  return results;\n}\n_c2 = PDF_TO_JSON;\nvar _c, _c2;\n$RefreshReg$(_c, \"DownloadUpdatedFile\");\n$RefreshReg$(_c2, \"PDF_TO_JSON\");","map":{"version":3,"names":["pdfjsLib","PDFDocument","rgb","GlobalWorkerOptions","workerSrc","version","DownloadUpdatedFile","pdfData","jsonResult","response","fetch","url","arrayBuffer","pdfDoc","load","form","getForm","i","length","fieldName","inputField","field","getTextField","setText","value","flatten","pdfBytes","save","blob","Blob","type","URL","createObjectURL","a","document","createElement","href","download","name","click","revokeObjectURL","_c","PDF_TO_JSON","loadingTask","getDocument","cMapUrl","cMapPacked","pdf","promise","console","log","results","numPages","page","getPage","textContent","getTextContent","annotations","getAnnotations","regionLabel","item","items","str","trim","x","y","transform","nearestField","minDistance","Infinity","annotation","x1","y1","x2","y2","rect","fieldY","fieldX","Math","abs","distance","label","inputType","fieldType","fieldValue","options","map","opt","displayValue","push","courtFileLabel","_c2","$RefreshReg$"],"sources":["C:/Users/Vidu/OneDrive/Desktop/Xenon Innovation/Expenser/client/src/components/FillForm/PdfToJson.js"],"sourcesContent":["import * as pdfjsLib from 'pdfjs-dist';\r\nimport { PDFDocument, rgb } from 'pdf-lib';\r\n\r\n// Set up the worker for pdf.js\r\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\r\nexport async function DownloadUpdatedFile(pdfData, jsonResult) {\r\n    const response = await fetch(pdfData.url);\r\n    const arrayBuffer = await response.arrayBuffer();\r\n    const pdfDoc = await PDFDocument.load(arrayBuffer);\r\n    const form = pdfDoc.getForm();\r\n\r\n    // Set values\r\n    for (let i = 0; i < jsonResult.length; i++) {\r\n        const fieldName = jsonResult[i].inputField.fieldName;\r\n        const field = form.getTextField(fieldName);\r\n        field.setText(jsonResult[i].inputField.value);\r\n    }\r\n\r\n\r\n    // fields become uneditable\r\n    form.flatten();\r\n\r\n    const pdfBytes = await pdfDoc.save();\r\n\r\n    // Trigger file download in the browser\r\n    const blob = new Blob([pdfBytes], { type: 'application/pdf' });\r\n    const url = URL.createObjectURL(blob);\r\n    const a = document.createElement('a');\r\n    a.href = url;\r\n    a.download = 'filled-form-' + pdfData.name+ '.pdf';\r\n    a.click();\r\n    URL.revokeObjectURL(url);\r\n}\r\nexport async function PDF_TO_JSON(pdfData) {\r\n    const loadingTask = pdfjsLib.getDocument({\r\n        url: pdfData.url,\r\n        cMapUrl: \"https://unpkg.com/pdfjs-dist@latest/cmaps/\",\r\n        cMapPacked: true,\r\n    });\r\n\r\n    const pdf = await loadingTask.promise;\r\n    console.log(\"PDF loaded successfully\");\r\n\r\n    const results = [];\r\n\r\n    for (let i = 1; i <= pdf.numPages; i++) {\r\n        const page = await pdf.getPage(i);\r\n        const textContent = await page.getTextContent();\r\n        const annotations = await page.getAnnotations();\r\n\r\n        // Find the \"Region\" label\r\n        let regionLabel = null;\r\n        for (const item of textContent.items) {\r\n            if (item.str.trim() === \"Region\") {\r\n                const [, , , , x, y] = item.transform;\r\n                regionLabel = { x, y };\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (regionLabel) {\r\n            // Find the nearest input field above the \"Region\" label\r\n            let nearestField = null;\r\n            let minDistance = Infinity;\r\n\r\n            for (const annotation of annotations) {\r\n                const [x1, y1, x2, y2] = annotation.rect;\r\n                const fieldY = (y1 + y2) / 2;\r\n                const fieldX = (x1 + x2) / 2;\r\n\r\n                // Check if the field is above the label and within horizontal range\r\n                if (fieldY > regionLabel.y && Math.abs(fieldX - regionLabel.x) < 100) {\r\n                    const distance = fieldY - regionLabel.y;\r\n                    if (distance < minDistance) {\r\n                        minDistance = distance;\r\n                        nearestField = {\r\n                            label: \"Region\",\r\n                            inputField: {\r\n                                fieldName: annotation.fieldName || \"Unnamed Field\",\r\n                                inputType: annotation.fieldType || \"Unknown\",\r\n                                value: annotation.fieldValue || \"\",\r\n                                options: annotation.options ? annotation.options.map(opt => opt.displayValue || opt.value) : []\r\n                            }\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (nearestField) {\r\n                results.push(nearestField);\r\n            }\r\n        }\r\n\r\n        // Find the \"Court File No. (if known)\" label\r\n        let courtFileLabel = null;\r\n        for (const item of textContent.items) {\r\n            if (item.str.trim() === \"Court File No. (if known)\") {\r\n                const [, , , , x, y] = item.transform;\r\n                courtFileLabel = { x, y };\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (courtFileLabel) {\r\n            // Find the nearest text input field above the label\r\n            let nearestField = null;\r\n            let minDistance = Infinity;\r\n\r\n            for (const annotation of annotations) {\r\n                const [x1, y1, x2, y2] = annotation.rect;\r\n                const fieldY = (y1 + y2) / 2;\r\n                const fieldX = (x1 + x2) / 2;\r\n\r\n                // Check if the field is above the label, within horizontal range, and is a text field\r\n                if (\r\n                    fieldY > courtFileLabel.y &&\r\n                    Math.abs(fieldX - courtFileLabel.x) < 100 &&\r\n                    annotation.fieldType === \"Tx\"\r\n                ) {\r\n                    const distance = fieldY - courtFileLabel.y;\r\n                    if (distance < minDistance) {\r\n                        minDistance = distance;\r\n                        nearestField = {\r\n                            label: \"Court File No. (if known)\",\r\n                            inputField: {\r\n                                fieldName: annotation.fieldName || \"Unnamed Field\",\r\n                                inputType: annotation.fieldType || \"Unknown\",\r\n                                value: annotation.fieldValue || \"\",\r\n                                options: []\r\n                            }\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (nearestField) {\r\n                results.push(nearestField);\r\n            }\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}