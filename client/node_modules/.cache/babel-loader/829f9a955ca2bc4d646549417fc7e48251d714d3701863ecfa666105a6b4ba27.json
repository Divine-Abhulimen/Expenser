{"ast":null,"code":"import * as pdfjsLib from 'pdfjs-dist';\n// import { PDFDocument, StandardFonts, rgb } from 'pdf-lib';\n// import { degrees, PDFDocument, rgb, StandardFonts } from 'pdf-lib-with-encrypt';\n\n// Set up the worker for pdf.js\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\nexport async function PDF_TO_JSON(pdfUrl) {\n  const loadingTask = pdfjsLib.getDocument({\n    url: pdfUrl,\n    cMapUrl: \"https://unpkg.com/pdfjs-dist@latest/cmaps/\",\n    cMapPacked: true\n  });\n  const pdf = await loadingTask.promise;\n  console.log(\"PDF loaded successfully\");\n\n  // Lines in the page\n  const pageData = {\n    lines: [],\n    pageInfo: {}\n  };\n\n  // Go through all the pages in reverse order (last page considered the first)\n  for (let i = 1; i <= pdf.numPages; i++) {\n    const page = await pdf.getPage(i);\n    const viewport = page.getViewport({\n      scale: 1\n    });\n    pageData.pageInfo[i] = {\n      width: viewport.width,\n      height: viewport.height\n    };\n\n    // Scan the information we get from the page\n    const annotations = await page.getAnnotations(); // Input fields (textboxes, dropdowns, etc.)\n\n    const pageText = await page.getTextContent(); // All text content\n    const items = pageText.items; // All text label items\n    // Process text items (group by line Y position)\n    const textLines = {};\n    items.forEach(item => {\n      const x = item.transform[4]; // X position\n      const y = item.transform[5]; // Y position\n      const font = item.fontName || \"Unknown Font\"; // Font name\n      const fontSize = item.height || \"Unknown Size\"; // Font size (height)\n\n      const isBold = font.toLowerCase().includes(\"bold\");\n      const isItalic = font.toLowerCase().includes(\"italic\");\n      const textData = {\n        x,\n        y,\n        text: item.str,\n        font,\n        fontSize,\n        isBold,\n        isItalic\n      };\n      if (!textLines[y]) {\n        textLines[y] = [];\n      }\n      textLines[y].push(textData); // stores the label information as an id of Y axis\n    });\n\n    // Sort the lines based on Y position (descending)\n    const sortedTextLines = Object.keys(textLines).sort((a, b) => parseFloat(b) - parseFloat(a));\n    sortedTextLines.forEach(lineY => {\n      // Here, we can go through each label line and get the input fields closer to them\n      const lineData = {\n        lineNumber: sortedTextLines.indexOf(lineY) + 1,\n        inputFields: [],\n        TextFoundInLine: []\n      };\n\n      // Add the text found in this line\n      textLines[lineY].forEach(item => {\n        lineData.TextFoundInLine.push(item.text);\n      });\n\n      // Check for form fields (input fields, buttons, labels, etc.) associated with this line\n      annotations.forEach(annotation => {\n        var _textLines$lineY$;\n        const [x, y, width, height] = annotation.rect;\n\n        // TODO: create an algorithm to filter questions and input boxes\n\n        // if (Math.abs(y - parseFloat(textLines[lineY][0]?.y)) < 40 &&\n        // Math.abs(x - parseFloat(textLines[lineY][0]?.x)) < 40\n        //TODO/NOTE: This condition is only radius based, not the whole above\n        if (Math.abs(y - parseFloat(lineY)) < 40 && Math.abs(x - parseFloat((_textLines$lineY$ = textLines[lineY][0]) === null || _textLines$lineY$ === void 0 ? void 0 : _textLines$lineY$.x)) < 40) {\n          let fieldData = {\n            inputType: \"Unknown\",\n            choices: [],\n            label: \"No associated label\",\n            coordinates: {\n              x,\n              y,\n              width,\n              height\n            },\n            font: \"Unknown\",\n            fontSize: \"Unknown\",\n            isBold: false,\n            isItalic: false\n          };\n\n          // Handle different field types\n          if (annotation.fieldType === \"Ch\") {\n            fieldData.inputType = \"Choice\";\n            fieldData.choices = annotation.options ? annotation.options.map(option => option.displayValue || option.value) : [];\n          } else if (annotation.fieldType === \"Tx\") {\n            fieldData.inputType = \"TextBox\";\n          } else if (annotation.fieldType === \"Btn\") {\n            if (annotation.subtype === \"CheckBox\" || annotation.fieldName && annotation.fieldName.toLowerCase().includes(\"chk\")) {\n              fieldData.inputType = \"CheckBox\";\n              fieldData.choices = [\"true\", \"false\"];\n            } else if (annotation.subtype === \"Radio\") {\n              fieldData.inputType = \"RadioButton\";\n              fieldData.choices = annotation.options ? annotation.options.map(option => option.displayValue || option.value) : [];\n            } else {\n              // Button case\n              fieldData.inputType = \"Button\";\n              const match = annotation.fieldName.match(/\\.([^.\\[]+)\\[0\\](?!.*\\])/);\n              fieldData.label = match ? match[1] : annotation.fieldName; // Extracted last method or fallback\n            }\n          }\n\n          // Add input field data to the line\n          lineData.inputFields.push({\n            fieldName: annotation.fieldName,\n            fieldData\n          });\n        }\n      });\n\n      // Push this line's data to the final pageData\n      pageData.lines.push(lineData);\n    });\n  }\n  return pageData;\n}\n_c = PDF_TO_JSON;\nexport async function download(pdfUrl) {\n  // Fetch the existing PDF\n  const existingPdfBytes = await fetch(pdfUrl).then(res => res.arrayBuffer());\n  const pdfDoc = await PDFDocument.load(existingPdfBytes);\n}\n\n// // Function to find nearby text for the label\n// function findLabelForAnnotation(x, y, width, height, textLines) {\n//     // Loop through the lines of text and find a matching label (based on proximity)\n//     for (const lineY in textLines) {\n//         const line = textLines[lineY];\n//         line.forEach(item => {\n//             const textX = item.x;\n//             const textY = item.y;\n\n//             // Check if text is near the annotation\n//             if (Math.abs(textY - y) < 30 && textX >= (x - 50) && textX <= (x + width + 50)) {\n//                 return item.text;  // Return the label\n//             }\n//         });\n//     }\n//     return null;\n// }\n\n// // Function to try fallback label detection\n// function findFallbackLabel(x, y, width, height, items) {\n//     const nearbyText = items.filter(item => {\n//         const textY = item.transform[5];\n//         const textX = item.transform[4];\n\n//         // Check if the text is close above the button\n//         const isAbove = textY < y && Math.abs(textY - y) < 30;\n//         const isHorizontallyAligned = textX >= (x - 50) && textX <= (x + width + 50);\n\n//         return isAbove && isHorizontallyAligned;\n//     });\n\n//     if (nearbyText.length > 0) {\n//         return nearbyText.map(item => item.str).join(\" \").trim();\n//     }\n//     return null;\n// }\nvar _c;\n$RefreshReg$(_c, \"PDF_TO_JSON\");","map":{"version":3,"names":["pdfjsLib","GlobalWorkerOptions","workerSrc","version","PDF_TO_JSON","pdfUrl","loadingTask","getDocument","url","cMapUrl","cMapPacked","pdf","promise","console","log","pageData","lines","pageInfo","i","numPages","page","getPage","viewport","getViewport","scale","width","height","annotations","getAnnotations","pageText","getTextContent","items","textLines","forEach","item","x","transform","y","font","fontName","fontSize","isBold","toLowerCase","includes","isItalic","textData","text","str","push","sortedTextLines","Object","keys","sort","a","b","parseFloat","lineY","lineData","lineNumber","indexOf","inputFields","TextFoundInLine","annotation","_textLines$lineY$","rect","Math","abs","fieldData","inputType","choices","label","coordinates","fieldType","options","map","option","displayValue","value","subtype","fieldName","match","_c","download","existingPdfBytes","fetch","then","res","arrayBuffer","pdfDoc","PDFDocument","load","$RefreshReg$"],"sources":["C:/Users/Vidu/OneDrive/Desktop/Xenon Innovation/Expenser/client/src/components/FillForm/PdfToJson.js"],"sourcesContent":["import * as pdfjsLib from 'pdfjs-dist';\r\n// import { PDFDocument, StandardFonts, rgb } from 'pdf-lib';\r\n// import { degrees, PDFDocument, rgb, StandardFonts } from 'pdf-lib-with-encrypt';\r\n\r\n// Set up the worker for pdf.js\r\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\r\n\r\nexport async function PDF_TO_JSON(pdfUrl) {\r\n    const loadingTask = pdfjsLib.getDocument({\r\n        url: pdfUrl,\r\n        cMapUrl: \"https://unpkg.com/pdfjs-dist@latest/cmaps/\",\r\n        cMapPacked: true,\r\n    });\r\n\r\n    const pdf = await loadingTask.promise;\r\n    console.log(\"PDF loaded successfully\");\r\n\r\n    // Lines in the page\r\n    const pageData = {\r\n        lines: [],\r\n        pageInfo: {}\r\n    };\r\n\r\n    // Go through all the pages in reverse order (last page considered the first)\r\n    for (let i = 1; i <= pdf.numPages; i++) {\r\n        const page = await pdf.getPage(i);\r\n        const viewport = page.getViewport({ scale: 1 });\r\n        pageData.pageInfo[i] = { width: viewport.width, height: viewport.height };\r\n\r\n\r\n        // Scan the information we get from the page\r\n        const annotations = await page.getAnnotations(); // Input fields (textboxes, dropdowns, etc.)\r\n\r\n        const pageText = await page.getTextContent(); // All text content\r\n        const items = pageText.items; // All text label items\r\n        // Process text items (group by line Y position)\r\n        const textLines = {};\r\n\r\n        items.forEach(item => {\r\n            const x = item.transform[4]; // X position\r\n            const y = item.transform[5]; // Y position\r\n            const font = item.fontName || \"Unknown Font\"; // Font name\r\n            const fontSize = item.height || \"Unknown Size\"; // Font size (height)\r\n\r\n            const isBold = font.toLowerCase().includes(\"bold\");\r\n            const isItalic = font.toLowerCase().includes(\"italic\");\r\n\r\n            const textData = {\r\n                x,\r\n                y,\r\n                text: item.str,\r\n                font,\r\n                fontSize,\r\n                isBold,\r\n                isItalic\r\n            };\r\n\r\n            if (!textLines[y]) {\r\n                textLines[y] = [];\r\n            }\r\n            textLines[y].push(textData); // stores the label information as an id of Y axis\r\n        });\r\n\r\n        // Sort the lines based on Y position (descending)\r\n        const sortedTextLines = Object.keys(textLines).sort((a, b) => parseFloat(b) - parseFloat(a));\r\n\r\n        sortedTextLines.forEach((lineY) => {\r\n            // Here, we can go through each label line and get the input fields closer to them\r\n            const lineData = {\r\n                lineNumber: sortedTextLines.indexOf(lineY) + 1,\r\n                inputFields: [],\r\n                TextFoundInLine: []\r\n            };\r\n\r\n            // Add the text found in this line\r\n            textLines[lineY].forEach(item => {\r\n                lineData.TextFoundInLine.push(item.text);\r\n            });\r\n\r\n            // Check for form fields (input fields, buttons, labels, etc.) associated with this line\r\n            annotations.forEach(annotation => {\r\n                const [x, y, width, height] = annotation.rect;\r\n\r\n\r\n                // TODO: create an algorithm to filter questions and input boxes\r\n\r\n                // if (Math.abs(y - parseFloat(textLines[lineY][0]?.y)) < 40 &&\r\n                // Math.abs(x - parseFloat(textLines[lineY][0]?.x)) < 40\r\n                //TODO/NOTE: This condition is only radius based, not the whole above\r\n                if (Math.abs(y - parseFloat(lineY)) < 40 &&\r\n                    Math.abs(x - parseFloat(textLines[lineY][0]?.x)) < 40\r\n                ) {\r\n                    let fieldData = {\r\n                        inputType: \"Unknown\",\r\n                        choices: [],\r\n                        label: \"No associated label\",\r\n                        coordinates: { x, y, width, height },\r\n                        font: \"Unknown\",\r\n                        fontSize: \"Unknown\",\r\n                        isBold: false,\r\n                        isItalic: false\r\n                    };\r\n\r\n                    // Handle different field types\r\n                    if (annotation.fieldType === \"Ch\") {\r\n                        fieldData.inputType = \"Choice\";\r\n                        fieldData.choices = annotation.options ? annotation.options.map(option => option.displayValue || option.value) : [];\r\n                    } else if (annotation.fieldType === \"Tx\") {\r\n                        fieldData.inputType = \"TextBox\";\r\n                    } else if (annotation.fieldType === \"Btn\") {\r\n                        if (annotation.subtype === \"CheckBox\" || (annotation.fieldName && annotation.fieldName.toLowerCase().includes(\"chk\"))) {\r\n                            fieldData.inputType = \"CheckBox\";\r\n                            fieldData.choices = [\"true\", \"false\"];\r\n                        } else if (annotation.subtype === \"Radio\") {\r\n                            fieldData.inputType = \"RadioButton\";\r\n                            fieldData.choices = annotation.options ? annotation.options.map(option => option.displayValue || option.value) : [];\r\n                        } else {\r\n                            // Button case\r\n                            fieldData.inputType = \"Button\";\r\n                            const match = annotation.fieldName.match(/\\.([^.\\[]+)\\[0\\](?!.*\\])/);\r\n                            fieldData.label = match ? match[1] : annotation.fieldName;  // Extracted last method or fallback\r\n                        }\r\n                    }\r\n\r\n                    // Add input field data to the line\r\n                    lineData.inputFields.push({\r\n                        fieldName: annotation.fieldName,\r\n                        fieldData\r\n                    });\r\n                }\r\n            });\r\n\r\n            // Push this line's data to the final pageData\r\n            pageData.lines.push(lineData);\r\n        });\r\n    }\r\n\r\n    return pageData;\r\n}\r\n\r\nexport async function download(pdfUrl) {\r\n    // Fetch the existing PDF\r\n    const existingPdfBytes = await fetch(pdfUrl).then(res => res.arrayBuffer());\r\n    const pdfDoc = await PDFDocument.load(existingPdfBytes);\r\n\r\n\r\n}\r\n\r\n// // Function to find nearby text for the label\r\n// function findLabelForAnnotation(x, y, width, height, textLines) {\r\n//     // Loop through the lines of text and find a matching label (based on proximity)\r\n//     for (const lineY in textLines) {\r\n//         const line = textLines[lineY];\r\n//         line.forEach(item => {\r\n//             const textX = item.x;\r\n//             const textY = item.y;\r\n\r\n//             // Check if text is near the annotation\r\n//             if (Math.abs(textY - y) < 30 && textX >= (x - 50) && textX <= (x + width + 50)) {\r\n//                 return item.text;  // Return the label\r\n//             }\r\n//         });\r\n//     }\r\n//     return null;\r\n// }\r\n\r\n// // Function to try fallback label detection\r\n// function findFallbackLabel(x, y, width, height, items) {\r\n//     const nearbyText = items.filter(item => {\r\n//         const textY = item.transform[5];\r\n//         const textX = item.transform[4];\r\n\r\n//         // Check if the text is close above the button\r\n//         const isAbove = textY < y && Math.abs(textY - y) < 30;\r\n//         const isHorizontallyAligned = textX >= (x - 50) && textX <= (x + width + 50);\r\n\r\n//         return isAbove && isHorizontallyAligned;\r\n//     });\r\n\r\n//     if (nearbyText.length > 0) {\r\n//         return nearbyText.map(item => item.str).join(\" \").trim();\r\n//     }\r\n//     return null;\r\n// }"],"mappings":"AAAA,OAAO,KAAKA,QAAQ,MAAM,YAAY;AACtC;AACA;;AAEA;AACAA,QAAQ,CAACC,mBAAmB,CAACC,SAAS,GAAG,2CAA2CF,QAAQ,CAACG,OAAO,oBAAoB;AAExH,OAAO,eAAeC,WAAWA,CAACC,MAAM,EAAE;EACtC,MAAMC,WAAW,GAAGN,QAAQ,CAACO,WAAW,CAAC;IACrCC,GAAG,EAAEH,MAAM;IACXI,OAAO,EAAE,4CAA4C;IACrDC,UAAU,EAAE;EAChB,CAAC,CAAC;EAEF,MAAMC,GAAG,GAAG,MAAML,WAAW,CAACM,OAAO;EACrCC,OAAO,CAACC,GAAG,CAAC,yBAAyB,CAAC;;EAEtC;EACA,MAAMC,QAAQ,GAAG;IACbC,KAAK,EAAE,EAAE;IACTC,QAAQ,EAAE,CAAC;EACf,CAAC;;EAED;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIP,GAAG,CAACQ,QAAQ,EAAED,CAAC,EAAE,EAAE;IACpC,MAAME,IAAI,GAAG,MAAMT,GAAG,CAACU,OAAO,CAACH,CAAC,CAAC;IACjC,MAAMI,QAAQ,GAAGF,IAAI,CAACG,WAAW,CAAC;MAAEC,KAAK,EAAE;IAAE,CAAC,CAAC;IAC/CT,QAAQ,CAACE,QAAQ,CAACC,CAAC,CAAC,GAAG;MAAEO,KAAK,EAAEH,QAAQ,CAACG,KAAK;MAAEC,MAAM,EAAEJ,QAAQ,CAACI;IAAO,CAAC;;IAGzE;IACA,MAAMC,WAAW,GAAG,MAAMP,IAAI,CAACQ,cAAc,CAAC,CAAC,CAAC,CAAC;;IAEjD,MAAMC,QAAQ,GAAG,MAAMT,IAAI,CAACU,cAAc,CAAC,CAAC,CAAC,CAAC;IAC9C,MAAMC,KAAK,GAAGF,QAAQ,CAACE,KAAK,CAAC,CAAC;IAC9B;IACA,MAAMC,SAAS,GAAG,CAAC,CAAC;IAEpBD,KAAK,CAACE,OAAO,CAACC,IAAI,IAAI;MAClB,MAAMC,CAAC,GAAGD,IAAI,CAACE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;MAC7B,MAAMC,CAAC,GAAGH,IAAI,CAACE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;MAC7B,MAAME,IAAI,GAAGJ,IAAI,CAACK,QAAQ,IAAI,cAAc,CAAC,CAAC;MAC9C,MAAMC,QAAQ,GAAGN,IAAI,CAACR,MAAM,IAAI,cAAc,CAAC,CAAC;;MAEhD,MAAMe,MAAM,GAAGH,IAAI,CAACI,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,MAAM,CAAC;MAClD,MAAMC,QAAQ,GAAGN,IAAI,CAACI,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,QAAQ,CAAC;MAEtD,MAAME,QAAQ,GAAG;QACbV,CAAC;QACDE,CAAC;QACDS,IAAI,EAAEZ,IAAI,CAACa,GAAG;QACdT,IAAI;QACJE,QAAQ;QACRC,MAAM;QACNG;MACJ,CAAC;MAED,IAAI,CAACZ,SAAS,CAACK,CAAC,CAAC,EAAE;QACfL,SAAS,CAACK,CAAC,CAAC,GAAG,EAAE;MACrB;MACAL,SAAS,CAACK,CAAC,CAAC,CAACW,IAAI,CAACH,QAAQ,CAAC,CAAC,CAAC;IACjC,CAAC,CAAC;;IAEF;IACA,MAAMI,eAAe,GAAGC,MAAM,CAACC,IAAI,CAACnB,SAAS,CAAC,CAACoB,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKC,UAAU,CAACD,CAAC,CAAC,GAAGC,UAAU,CAACF,CAAC,CAAC,CAAC;IAE5FJ,eAAe,CAAChB,OAAO,CAAEuB,KAAK,IAAK;MAC/B;MACA,MAAMC,QAAQ,GAAG;QACbC,UAAU,EAAET,eAAe,CAACU,OAAO,CAACH,KAAK,CAAC,GAAG,CAAC;QAC9CI,WAAW,EAAE,EAAE;QACfC,eAAe,EAAE;MACrB,CAAC;;MAED;MACA7B,SAAS,CAACwB,KAAK,CAAC,CAACvB,OAAO,CAACC,IAAI,IAAI;QAC7BuB,QAAQ,CAACI,eAAe,CAACb,IAAI,CAACd,IAAI,CAACY,IAAI,CAAC;MAC5C,CAAC,CAAC;;MAEF;MACAnB,WAAW,CAACM,OAAO,CAAC6B,UAAU,IAAI;QAAA,IAAAC,iBAAA;QAC9B,MAAM,CAAC5B,CAAC,EAAEE,CAAC,EAAEZ,KAAK,EAAEC,MAAM,CAAC,GAAGoC,UAAU,CAACE,IAAI;;QAG7C;;QAEA;QACA;QACA;QACA,IAAIC,IAAI,CAACC,GAAG,CAAC7B,CAAC,GAAGkB,UAAU,CAACC,KAAK,CAAC,CAAC,GAAG,EAAE,IACpCS,IAAI,CAACC,GAAG,CAAC/B,CAAC,GAAGoB,UAAU,EAAAQ,iBAAA,GAAC/B,SAAS,CAACwB,KAAK,CAAC,CAAC,CAAC,CAAC,cAAAO,iBAAA,uBAAnBA,iBAAA,CAAqB5B,CAAC,CAAC,CAAC,GAAG,EAAE,EACvD;UACE,IAAIgC,SAAS,GAAG;YACZC,SAAS,EAAE,SAAS;YACpBC,OAAO,EAAE,EAAE;YACXC,KAAK,EAAE,qBAAqB;YAC5BC,WAAW,EAAE;cAAEpC,CAAC;cAAEE,CAAC;cAAEZ,KAAK;cAAEC;YAAO,CAAC;YACpCY,IAAI,EAAE,SAAS;YACfE,QAAQ,EAAE,SAAS;YACnBC,MAAM,EAAE,KAAK;YACbG,QAAQ,EAAE;UACd,CAAC;;UAED;UACA,IAAIkB,UAAU,CAACU,SAAS,KAAK,IAAI,EAAE;YAC/BL,SAAS,CAACC,SAAS,GAAG,QAAQ;YAC9BD,SAAS,CAACE,OAAO,GAAGP,UAAU,CAACW,OAAO,GAAGX,UAAU,CAACW,OAAO,CAACC,GAAG,CAACC,MAAM,IAAIA,MAAM,CAACC,YAAY,IAAID,MAAM,CAACE,KAAK,CAAC,GAAG,EAAE;UACvH,CAAC,MAAM,IAAIf,UAAU,CAACU,SAAS,KAAK,IAAI,EAAE;YACtCL,SAAS,CAACC,SAAS,GAAG,SAAS;UACnC,CAAC,MAAM,IAAIN,UAAU,CAACU,SAAS,KAAK,KAAK,EAAE;YACvC,IAAIV,UAAU,CAACgB,OAAO,KAAK,UAAU,IAAKhB,UAAU,CAACiB,SAAS,IAAIjB,UAAU,CAACiB,SAAS,CAACrC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,KAAK,CAAE,EAAE;cACnHwB,SAAS,CAACC,SAAS,GAAG,UAAU;cAChCD,SAAS,CAACE,OAAO,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC;YACzC,CAAC,MAAM,IAAIP,UAAU,CAACgB,OAAO,KAAK,OAAO,EAAE;cACvCX,SAAS,CAACC,SAAS,GAAG,aAAa;cACnCD,SAAS,CAACE,OAAO,GAAGP,UAAU,CAACW,OAAO,GAAGX,UAAU,CAACW,OAAO,CAACC,GAAG,CAACC,MAAM,IAAIA,MAAM,CAACC,YAAY,IAAID,MAAM,CAACE,KAAK,CAAC,GAAG,EAAE;YACvH,CAAC,MAAM;cACH;cACAV,SAAS,CAACC,SAAS,GAAG,QAAQ;cAC9B,MAAMY,KAAK,GAAGlB,UAAU,CAACiB,SAAS,CAACC,KAAK,CAAC,0BAA0B,CAAC;cACpEb,SAAS,CAACG,KAAK,GAAGU,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAGlB,UAAU,CAACiB,SAAS,CAAC,CAAE;YAChE;UACJ;;UAEA;UACAtB,QAAQ,CAACG,WAAW,CAACZ,IAAI,CAAC;YACtB+B,SAAS,EAAEjB,UAAU,CAACiB,SAAS;YAC/BZ;UACJ,CAAC,CAAC;QACN;MACJ,CAAC,CAAC;;MAEF;MACApD,QAAQ,CAACC,KAAK,CAACgC,IAAI,CAACS,QAAQ,CAAC;IACjC,CAAC,CAAC;EACN;EAEA,OAAO1C,QAAQ;AACnB;AAACkE,EAAA,GAnIqB7E,WAAW;AAqIjC,OAAO,eAAe8E,QAAQA,CAAC7E,MAAM,EAAE;EACnC;EACA,MAAM8E,gBAAgB,GAAG,MAAMC,KAAK,CAAC/E,MAAM,CAAC,CAACgF,IAAI,CAACC,GAAG,IAAIA,GAAG,CAACC,WAAW,CAAC,CAAC,CAAC;EAC3E,MAAMC,MAAM,GAAG,MAAMC,WAAW,CAACC,IAAI,CAACP,gBAAgB,CAAC;AAG3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA,IAAAF,EAAA;AAAAU,YAAA,CAAAV,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}