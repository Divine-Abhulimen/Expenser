{"ast":null,"code":"import * as pdfjsLib from 'pdfjs-dist';\nimport { PDFDocument, rgb } from 'pdf-lib';\n\n// Set up the worker for pdf.js\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\nexport async function DownloadUpdatedFile(pdfData, jsonResult) {\n  const response = await fetch(pdfData.url);\n  const arrayBuffer = await response.arrayBuffer();\n  const pdfDoc = await PDFDocument.load(arrayBuffer);\n  const form = pdfDoc.getForm();\n\n  // Set values\n  for (let i = 0; i < jsonResult.length; i++) {\n    const fieldName = jsonResult[i].inputField.fieldName;\n    const fieldValue = jsonResult[i].inputField.value;\n    const field = form.getFieldMaybe(fieldName);\n    if (field) {\n      const fieldType = field.constructor.name;\n      switch (fieldType) {\n        case 'PDFTextField':\n          field.setText(fieldValue);\n          break;\n        case 'PDFDropdown':\n          field.select(fieldValue);\n          break;\n        case 'PDFCheckBox':\n          field.check();\n          break;\n        // Add other field types as needed\n        default:\n          console.warn(`Unsupported field type: ${fieldType}`);\n      }\n    } else {\n      console.warn(`Field '${fieldName}' not found.`);\n    }\n  }\n\n  // fields become uneditable\n  form.flatten();\n  const pdfBytes = await pdfDoc.save();\n\n  // Trigger file download in the browser\n  const blob = new Blob([pdfBytes], {\n    type: 'application/pdf'\n  });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = 'filled-form-' + pdfData.name + '.pdf';\n  a.click();\n  URL.revokeObjectURL(url);\n}\n_c = DownloadUpdatedFile;\nexport async function PDF_TO_JSON(pdfData) {\n  const loadingTask = pdfjsLib.getDocument({\n    url: pdfData.url,\n    cMapUrl: \"https://unpkg.com/pdfjs-dist@latest/cmaps/\",\n    cMapPacked: true\n  });\n  const pdf = await loadingTask.promise;\n  console.log(\"PDF loaded successfully\");\n  const results = [];\n  for (let i = 1; i <= pdf.numPages; i++) {\n    const page = await pdf.getPage(i);\n    const textContent = await page.getTextContent();\n    const annotations = await page.getAnnotations();\n\n    // Find the \"Region\" label\n    let regionLabel = null;\n    for (const item of textContent.items) {\n      if (item.str.trim() === \"Region\") {\n        const [,,,, x, y] = item.transform;\n        regionLabel = {\n          x,\n          y\n        };\n        break;\n      }\n    }\n    if (regionLabel) {\n      // Find the nearest input field above the \"Region\" label\n      let nearestField = null;\n      let minDistance = Infinity;\n      for (const annotation of annotations) {\n        const [x1, y1, x2, y2] = annotation.rect;\n        const fieldY = (y1 + y2) / 2;\n        const fieldX = (x1 + x2) / 2;\n\n        // Check if the field is above the label and within horizontal range\n        if (fieldY > regionLabel.y && Math.abs(fieldX - regionLabel.x) < 100) {\n          const distance = fieldY - regionLabel.y;\n          if (distance < minDistance) {\n            minDistance = distance;\n            nearestField = {\n              label: \"Region\",\n              inputField: {\n                fieldName: annotation.fieldName || \"Unnamed Field\",\n                inputType: annotation.fieldType || \"Unknown\",\n                value: annotation.fieldValue || \"\",\n                options: annotation.options ? annotation.options.map(opt => opt.displayValue || opt.value) : []\n              }\n            };\n          }\n        }\n      }\n      if (nearestField) {\n        results.push(nearestField);\n      }\n    }\n\n    // Find the \"Court File No. (if known)\" label\n    let courtFileLabel = null;\n    for (const item of textContent.items) {\n      if (item.str.trim() === \"Court File No. (if known)\") {\n        const [,,,, x, y] = item.transform;\n        courtFileLabel = {\n          x,\n          y\n        };\n        break;\n      }\n    }\n    if (courtFileLabel) {\n      // Find the nearest text input field above the label\n      let nearestField = null;\n      let minDistance = Infinity;\n      for (const annotation of annotations) {\n        const [x1, y1, x2, y2] = annotation.rect;\n        const fieldY = (y1 + y2) / 2;\n        const fieldX = (x1 + x2) / 2;\n\n        // Check if the field is above the label, within horizontal range, and is a text field\n        if (fieldY > courtFileLabel.y && Math.abs(fieldX - courtFileLabel.x) < 100 && annotation.fieldType === \"Tx\") {\n          const distance = fieldY - courtFileLabel.y;\n          if (distance < minDistance) {\n            minDistance = distance;\n            nearestField = {\n              label: \"Court File No. (if known)\",\n              inputField: {\n                fieldName: annotation.fieldName || \"Unnamed Field\",\n                inputType: annotation.fieldType || \"Unknown\",\n                value: annotation.fieldValue || \"\",\n                options: []\n              }\n            };\n          }\n        }\n      }\n      if (nearestField) {\n        results.push(nearestField);\n      }\n    }\n  }\n  return results;\n}\n_c2 = PDF_TO_JSON;\nvar _c, _c2;\n$RefreshReg$(_c, \"DownloadUpdatedFile\");\n$RefreshReg$(_c2, \"PDF_TO_JSON\");","map":{"version":3,"names":["pdfjsLib","PDFDocument","rgb","GlobalWorkerOptions","workerSrc","version","DownloadUpdatedFile","pdfData","jsonResult","response","fetch","url","arrayBuffer","pdfDoc","load","form","getForm","i","length","fieldName","inputField","fieldValue","value","field","getFieldMaybe","fieldType","constructor","name","setText","select","check","console","warn","flatten","pdfBytes","save","blob","Blob","type","URL","createObjectURL","a","document","createElement","href","download","click","revokeObjectURL","_c","PDF_TO_JSON","loadingTask","getDocument","cMapUrl","cMapPacked","pdf","promise","log","results","numPages","page","getPage","textContent","getTextContent","annotations","getAnnotations","regionLabel","item","items","str","trim","x","y","transform","nearestField","minDistance","Infinity","annotation","x1","y1","x2","y2","rect","fieldY","fieldX","Math","abs","distance","label","inputType","options","map","opt","displayValue","push","courtFileLabel","_c2","$RefreshReg$"],"sources":["C:/Users/Vidu/OneDrive/Desktop/Xenon Innovation/Expenser/client/src/components/FillForm/PdfToJson.js"],"sourcesContent":["import * as pdfjsLib from 'pdfjs-dist';\r\nimport { PDFDocument, rgb } from 'pdf-lib';\r\n\r\n// Set up the worker for pdf.js\r\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\r\nexport async function DownloadUpdatedFile(pdfData, jsonResult) {\r\n    const response = await fetch(pdfData.url);\r\n    const arrayBuffer = await response.arrayBuffer();\r\n    const pdfDoc = await PDFDocument.load(arrayBuffer);\r\n    const form = pdfDoc.getForm();\r\n\r\n    // Set values\r\n    for (let i = 0; i < jsonResult.length; i++) {\r\n        const fieldName = jsonResult[i].inputField.fieldName;\r\n        const fieldValue = jsonResult[i].inputField.value;\r\n        const field = form.getFieldMaybe(fieldName);\r\n\r\n        if (field) {\r\n            const fieldType = field.constructor.name;\r\n\r\n            switch (fieldType) {\r\n                case 'PDFTextField':\r\n                    field.setText(fieldValue);\r\n                    break;\r\n                case 'PDFDropdown':\r\n                    field.select(fieldValue);\r\n                    break;\r\n                case 'PDFCheckBox':\r\n                    field.check();\r\n                    break;\r\n                // Add other field types as needed\r\n                default:\r\n                    console.warn(`Unsupported field type: ${fieldType}`);\r\n            }\r\n        } else {\r\n            console.warn(`Field '${fieldName}' not found.`);\r\n        }\r\n    }\r\n\r\n\r\n    // fields become uneditable\r\n    form.flatten();\r\n\r\n    const pdfBytes = await pdfDoc.save();\r\n\r\n    // Trigger file download in the browser\r\n    const blob = new Blob([pdfBytes], { type: 'application/pdf' });\r\n    const url = URL.createObjectURL(blob);\r\n    const a = document.createElement('a');\r\n    a.href = url;\r\n    a.download = 'filled-form-' + pdfData.name+ '.pdf';\r\n    a.click();\r\n    URL.revokeObjectURL(url);\r\n}\r\nexport async function PDF_TO_JSON(pdfData) {\r\n    const loadingTask = pdfjsLib.getDocument({\r\n        url: pdfData.url,\r\n        cMapUrl: \"https://unpkg.com/pdfjs-dist@latest/cmaps/\",\r\n        cMapPacked: true,\r\n    });\r\n\r\n    const pdf = await loadingTask.promise;\r\n    console.log(\"PDF loaded successfully\");\r\n\r\n    const results = [];\r\n\r\n    for (let i = 1; i <= pdf.numPages; i++) {\r\n        const page = await pdf.getPage(i);\r\n        const textContent = await page.getTextContent();\r\n        const annotations = await page.getAnnotations();\r\n\r\n        // Find the \"Region\" label\r\n        let regionLabel = null;\r\n        for (const item of textContent.items) {\r\n            if (item.str.trim() === \"Region\") {\r\n                const [, , , , x, y] = item.transform;\r\n                regionLabel = { x, y };\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (regionLabel) {\r\n            // Find the nearest input field above the \"Region\" label\r\n            let nearestField = null;\r\n            let minDistance = Infinity;\r\n\r\n            for (const annotation of annotations) {\r\n                const [x1, y1, x2, y2] = annotation.rect;\r\n                const fieldY = (y1 + y2) / 2;\r\n                const fieldX = (x1 + x2) / 2;\r\n\r\n                // Check if the field is above the label and within horizontal range\r\n                if (fieldY > regionLabel.y && Math.abs(fieldX - regionLabel.x) < 100) {\r\n                    const distance = fieldY - regionLabel.y;\r\n                    if (distance < minDistance) {\r\n                        minDistance = distance;\r\n                        nearestField = {\r\n                            label: \"Region\",\r\n                            inputField: {\r\n                                fieldName: annotation.fieldName || \"Unnamed Field\",\r\n                                inputType: annotation.fieldType || \"Unknown\",\r\n                                value: annotation.fieldValue || \"\",\r\n                                options: annotation.options ? annotation.options.map(opt => opt.displayValue || opt.value) : []\r\n                            }\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (nearestField) {\r\n                results.push(nearestField);\r\n            }\r\n        }\r\n\r\n        // Find the \"Court File No. (if known)\" label\r\n        let courtFileLabel = null;\r\n        for (const item of textContent.items) {\r\n            if (item.str.trim() === \"Court File No. (if known)\") {\r\n                const [, , , , x, y] = item.transform;\r\n                courtFileLabel = { x, y };\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (courtFileLabel) {\r\n            // Find the nearest text input field above the label\r\n            let nearestField = null;\r\n            let minDistance = Infinity;\r\n\r\n            for (const annotation of annotations) {\r\n                const [x1, y1, x2, y2] = annotation.rect;\r\n                const fieldY = (y1 + y2) / 2;\r\n                const fieldX = (x1 + x2) / 2;\r\n\r\n                // Check if the field is above the label, within horizontal range, and is a text field\r\n                if (\r\n                    fieldY > courtFileLabel.y &&\r\n                    Math.abs(fieldX - courtFileLabel.x) < 100 &&\r\n                    annotation.fieldType === \"Tx\"\r\n                ) {\r\n                    const distance = fieldY - courtFileLabel.y;\r\n                    if (distance < minDistance) {\r\n                        minDistance = distance;\r\n                        nearestField = {\r\n                            label: \"Court File No. (if known)\",\r\n                            inputField: {\r\n                                fieldName: annotation.fieldName || \"Unnamed Field\",\r\n                                inputType: annotation.fieldType || \"Unknown\",\r\n                                value: annotation.fieldValue || \"\",\r\n                                options: []\r\n                            }\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (nearestField) {\r\n                results.push(nearestField);\r\n            }\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}